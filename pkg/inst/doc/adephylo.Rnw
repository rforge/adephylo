\documentclass{article}
%\VignettePackage{adephylo}
% \VignetteIndexEntry{adephylo: exploratory analyses for the
% phylogenetic comparative method}
\usepackage{graphicx}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{array}
\usepackage{color}

\usepackage[utf8]{inputenc} % for UTF-8/single quotes from sQuote()
\newcommand{\code}[1]{{{\tt #1}}}
\title{The \code{adephylo} package}
\author{Thibaut Jombart}
\date{\today}

\definecolor{Soutput}{rgb}{0,0,0.56}
\definecolor{Sinput}{rgb}{0.56,0,0}
\DefineVerbatimEnvironment{Sinput}{Verbatim}
{formatcom={\color{Sinput}},fontsize=\footnotesize, baselinestretch=0.75}
\DefineVerbatimEnvironment{Soutput}{Verbatim}
{formatcom={\color{Soutput}},fontsize=\footnotesize, baselinestretch=0.75}



\sloppy
\hyphenpenalty 10000


\begin{document}
\color{black}

\maketitle
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%

\SweaveOpts{prefix.string = figs/adephylo, fig = FALSE, eps = FALSE, pdf = TRUE, width = 6, height = 6}

This document describes the \code{adephylo} package for the R software.
\code{adephylo} aims at implementing exploratory methods for the
analysis of phylogenetic comparative data, i.e. biological traits measured for
taxa whose phylogeny is also provided.
Procedures implemented in this package rely on exploratory data
analysis.
They include data visualization and manipulation, tests for phylogenetic
autocorrelation, multivariate analysis, computation of phylogenetic
proximities and distances, and modelling phylogenetic signal using
orthonormal bases.
\\

These methods can be used to visualize, test, remove or investigate
the phylogenetic signal in comparative data.
The purpose of this document is to provide a general view a the main
functionalities of \code{adephylo}, and to show how this package can be
used along with \code{ape}, \code{phylobase} and \code{ade4} to
analyse comparative data.






%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\section{First steps into \code{adephylo}}
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%
\subsection{Data representation: why we are not reinventing the weel}
%%%%%%%%%%%%%%%%%%%%%
Data representation can be defined as the way data are stored in a
software (R, in our case).
Technically, they are classes of objects containing the information.
In the case of phylogeny, and comparative data, very efficient data
representation are already defined in other packages.
Hence, it made much more sense using directly objects from these classes.
\\


Phylogenies are best represented in Emmanuel Paradis's \code{ape}
package (\url{http://ape.mpl.ird.fr/}),
as the class \code{phylo}. Note that as \code{ape} is by far the
largest package dedicated to phylogeny, using the \code{phylo} class
assures a good interoperability of data. This class is defined in an
online document: \url{http://ape.mpl.ird.fr/misc/FormatTreeR_28July2008.pdf}.
\\

However, data that are to be analyzed in \code{adephylo} do not only
contain trees, but also traits associated to the tips of a tree.
The package \code{phylobase}
(\url{http://r-forge.r-project.org/projects/phylobase/}) is a
collaborative effort designed to the handling of such data.
Its representation of phylogenies is very similar to that of
\code{ape}: the class \code{phylo4} basically is an extension of
\code{phylo} class into formal (S4) class.
More interestingly, the S4 class \code{phylo4d} can be used to store a
tree and data associated to tips, internal nodes, or even edges of a tree.
Classes of \code{phylobase} are described in a vignette of the
package, accessible by typing:
<<eval=FALSE>>=
vignette("phylobase", package="phylobase")
@

~\\
As trees and comparative data are already handled by \code{ape} and
\code{phylobase}, no particular data format shall be defined in
\code{adephylo}.
In particular, we are no longer using \code{phylog} objects, which
were used to represent phylogenies in \code{ade4}.
This class is now deprecated, but all previous functionalities
available for \code{phylog} objects have been re-implemented and
-- in some cases -- improved in \code{adephylo}.





%%%%%%%%%%%%%%%%%%%%%
\subsection{Installing the package}
%%%%%%%%%%%%%%%%%%%%%
What is tricky here is that a vignette is basically available once the
package is installed.
Assuming you got this document before installing the package, here are
some clues about installing \code{adephylo}.
\\

First of all, \code{adephylo} depends on other packages, being
\code{methods}, \code{ape}, \code{phylobase}, and \code{ade4}.
These dependencies are mandatory, that is, you actually need to have
these packages installed (with or without their dependencies) before
using \code{adephylo}.
Also, it is better to make sure you are using the latest versions of
these packages. This can be achieved by typing
\texttt{update.packages}, or (better for \code{ade4} and \code{phylobase}) by installing devel versions
from R-Forge (\url{http://r-forge.r-project.org/}).
In all cases, the latest version of \code{adephylo} can be found from
\url{http://r-forge.r-project.org/R/?group_id=303}.
\\

When loading the package, dependencies are also loaded:
<<load>>=
library(adephylo)
@

Note that possibly conflicting, deprecated functions or datasets from \code{ade4} are
masked by \code{adephylo}.
In case the converse would occur (i.e. deprecated function masking a
function of \code{adephylo}), one can refer to the 'good' version of a
function by adding the prefix \code{adephylo::} to the function,
without space.
Hence, it is possibly to coerce the version of a masked function,
using a kludge like:
<<kludge>>=
cat("\n=== Old - deprecated- version ===\n")
orthogram <- ade4::orthogram
args(orthogram)
cat("\n=== New version === \n")
orthogram <- adephylo::orthogram
args(orthogram)
@

Luckily, this should not be required as long as one is not playing
with loading and unloading \code{ade4} once \code{adephylo} is loaded.


%%%%%%%%%%%%%%%%%%%%%
\subsection{Getting started}
%%%%%%%%%%%%%%%%%%%%%
All the material of the package is summarized in a manpage accessible
by typing:
<<eval=FALSE>>=
?adephylo
@

Note that a html version may be preferred to browse easily the content
of \code{adephylo}; this is accessible by typing:
<<eval=FALSE>>=
help("adephylo", package="adephylo", html=TRUE)
@

To revert help back to text mode, simply type:
<<eval=FALSE>>=
options(htmlhelp = FALSE)
@





%%%%%%%%%%%%%%%%%%%%%
\subsection{Putting data into shape}
%%%%%%%%%%%%%%%%%%%%%
While this is not the purpose of this document to go through the
details of \code{phylo}, \code{phylo4} and \code{phylo4d} objects, we
shall show briefly how these objects can be obtained.


% % % % % % % % % % %
\subsubsection{Making a \code{phylo} object}
% % % % % % % % % % %
The simplest way of turning a tree into a \code{phylo} object is using
ape's function \code{read.tree}.
This function reads a tree with the Newick (or 'parentetic') format,
from a file (default, argument \code{file}) of from a character string
(argument \code{text}).
<<readTree, plot=TRUE>>=
data(ungulates)
ungulates$tre
myTree <- read.tree(text=ungulates$tre)
myTree
plot(myTree, main="ape's plotting of a tree")
@


It is easy to convert \code{ade4}'s \code{phylog} objects to a
\code{phylo}, as \code{phylog} objects store the Newick format of the
tree in the \code{\$tre} component.
\\

Note that \code{phylo} trees can also be constructed from alignements
(see \code{read.GenBankdist.dna}, \code{read.dna},
\code{dist.dna}, \code{nj}, \code{bionj}, and \code{mlphylo}, all in
\code{ape}), or even simulated (for instance, see \code{rtree}).
\\

Also note that, if needed, conversion can be done back and forward
with \code{phylo4} trees:
<<>>=
temp <- as(myTree, "phylo4")
class(temp)
temp <- as(temp, "phylo")
class(temp)
all.equal(temp, myTree)
@





% % % % % % % % % % %
\subsubsection{Making a \code{phylo4d} object}
% % % % % % % % % % %
\code{phylo4d} objects are S4 objects, and are thus created in a
particular way.
The most immediate way of creating a \code{phylo4d} object is to call
to the constructor, also named \code{phylo4d}.
This is a function that takes two arguments: a tree (\code{phylo} or
\code{phylo4} format) and a data.frame containing data, for tips by
default (see \code{?phylo4d} for more information).
Here is an example:
<<phylo4d, fig=TRUE>>=
ung <- phylo4d(myTree, ungulates$tab)
class(ung)
table.phylo4d(ung)
@

\noindent Note that the constructor checks the consistency of the
names used for the tips of the tree and for the rows of the data.frame.
Inconsistencies issue an error.
To override this behaviour, one can specify
\code{use.tip.names=FALSE}.
However, this can be tricky: often, mismatches between names can
indicate that data are not sorted adequately; moreover, object created
with such mismatches will often be invalid objects, and may issue
errors in further analyses.
\\

Data are stored inside the slot \code{@tip.data} of the object.
They can be accessed either via this slot (in our example,
\code{ung@tip.data}), or using the function \code{tdata}:
<<>>=
x <- tdata(ung)
head(x)
@






%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\section{Exploratory data analysis}
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%
\subsection{Quantifying and testing phylogenetic signal}
%%%%%%%%%%%%%%%%%%%%%
In this document, the terms 'phylogenetic signal' and 'phylogenetic
autocorrelation' are used interchangeably.
They refer to the fact that observations of traits are not independent
in closely related taxa.
Several procedures are implemented by \code{adephylo} to measure and
test phylogenetic autocorrelation.


% % % % % % % % % % %
\subsubsection{Moran's $I$}
% % % % % % % % % % %
The function \code{moran.idx} computes Moran's $I$, the most
widely-used autocorrelation measure.
It can also provide additionnal information (argument \code{addInfo}),
being the null value of $I$ (i.e., the expected value in absence of
phylogenetic autocorrelation), and the range of variation of $I$.
It requires the degree of relatedness of tips on the phylogeny to be
modelled by a matrix of phylogenetic proximities.
Such a matrix can be obtained using different methods implemented by
the function \code{proxTips}.

<<moranI>>=
W <- proxTips(myTree, met="Abouheif")
moran.idx(tdata(ung)$afbw, W)
moran.idx(ung$tip.data[,1], W, addInfo=TRUE)
@

From here, it is quite straightforward to build a non-parametric test
based on Moran's $I$.
For instance (taken from \code{?moran.idx}):
<<fig=TRUE>>=
afbw <- tdata(ung)$afbw
sim <- replicate(499, moran.idx(sample(afbw), W)) # permutations
sim <- c(moran.idx(afbw, W), sim)

cat("\n=== p-value (right-tail) === \n")
pval <- mean(sim>=sim[1])
pval

plot(density(sim), main="Moran's I Monte Carlo test for 'bif'") # plot
mtext("Density of permutations, and observation (in red)")
abline(v=sim[1], col="red", lwd=3)

@

\noindent Here, \code{afbw} is likely not phylogenetically autocorrelated.





% % % % % % % % % % %
\subsubsection{Abouheif's test}
% % % % % % % % % % %

The test of Abouheif (see reference in \code{?abouheif.moran}) is
designed to test the existence of phylogenetic signal.
In fact, it has been shown that this test amounts to a Moran's $I$
test with a particular proximity matrix (again, see references in the manpage).
The implementation in \code{abouheif.moran} proposes different phylogenetic proximities,
using by default the original one.

The function can be used on different objects; in particular, it can
be used with a \code{phylo4d} object.
In such case, all traits inside the object are tested.
The returned object is a \code{krandtest}, a class of object defined
by \code{ade4} to store multiple Monte Carlo tests.
Here is an example using the ungulates dataset:
<<abouheif, plot=TRUE>>=
ung.abTests <- abouheif.moran(ung)
ung.abTests
plot(ung.abTests)
@

\noindent In this case, it seems that all variables but \code{afbm} are
phylogenetically structured.
\\

Note that other proximities than those proposed in
\code{abouheif.moran} can be used: on has just to pass the appropriate
proximity matrix to the function (argument \code{W}).
For instance, we would like to use the correlation corresponding to a
Brownian motion as a measure of phylogenetic proximity.

First, we must estimate branch lengths, as the tree we possess does
not have any:
<<>>=
hasEdgeLength(ung)
myTree.withBrLe <- compute.brlen(myTree)
@

\noindent Now, we can use ape's function \code{vcv.phylo} to compute
the matrix of phylogenetic proximities, and use this matrix in
Abouheif's test:
<<>>=
myProx <- vcv.phylo(myTree.withBrLe)
abouheif.moran(ung, W=myProx)
@

\noindent In the present case, traits no longer appear as
phylogenetically autocorrelated.
Several explanation can be proposed: the procedure for estimating
branch length might not have been appropriate, or the Brownian motion
may simply not be appropriate to describe the evolution of the traits
under study for this set of taxa.




% % % % % % % % % % %
\subsubsection{Phylogenetic decomposition of trait variation}
% % % % % % % % % % %
The phylogenetic decomposition of the variation of a trait proposed by Ollier
et al. (2005, see references in \code{?orthogram}) is implemented by
the function \code{orthogram}.
This function replaces the former, deprecated version from \code{ade4}.
\\

The idea behind the method is to model different levels of variation
on a phylogeny.
Basically, these levels can be obtained from dummy vectors indicating
which tip descends from a given node.
A partition of tips can then be obtained for each node.
This job is achieved by the function \code{treePart}.
Here is an example using a small simulated tree:
<<treePart,fig=TRUE>>=
x <- rcoal(5)
plot(x, show.node=TRUE)
nodelabels(paste("N",1:4,sep=""))
treePart(x)
@

\noindent The obtained partition can also be plotted:
<<fig=TRUE>>=
temp <- phylo4d(x, treePart(x))
table.phylo4d(temp, cent=FALSE, scale=FALSE)
@

\noindent What we would like to do is assess where the variation of a trait is localized on
the phylogeny; to do so, be could use these dummy vectors as
regressors and see how variation is distributed among these vectors.
However, these dummy vectors cannot be used as regressors because they
are linearly dependent.
The orthogram circumvents this issue by transforming and selecting
dummy vectors into a new set of variables that are orthonormal.
The obtained orthonormal basis can be used to decompose variation of
the trait.
Even if not necessary to get an orthogram, this basis can be obtained
from \code{treePart}:
<<>>=
args(treePart)
temp <- phylo4d(x, treePart(x, result="orthobasis") )
table.phylo4d(temp)
@

\noindent And here are the first 10 vectors of the orthonormal basis
for the ungulate dataset:
<<fig=TRUE>>=
temp <- phylo4d(myTree, treePart(myTree, result="orthobasis") )
par(mar=rep(.1,4))
table.phylo4d(temp, repVar=1:8)
@

The decomposition of variance achieved by projecting a trait onto this
orthonormal basis gives rise to several test statistics, that are
performed by the function \code{orthogram}.
Like the \code{abouheif.moran} function, \code{orthogram} outputs a
\code{krandtest} object:
<<orthogram, plot=TRUE>>=
afbw.ortgTest <- orthogram(afbw, myTree)
afbw.ortgTest
@

\noindent Here again, \code{afbw} does not seem to be phylogenetically structured.





%%%%%%%%%%%%%%%%%%%%%
\subsection{Modelling phylogenetic signal}
%%%%%%%%%%%%%%%%%%%%%

% % % % % % % % % % %
\subsubsection{Using orthonormal bases}
% % % % % % % % % % %

In fact, the previous section describing the 'orthogram' has already
shown that testing phylogenetic signal can (often) underlie modelling
phylogenetic signal.
In the case of the orthogram, several tests are linked to the
decomposition of the variance of a trait onto a particular basis describing tree topology.
In fact, it is possible to extend the principle of the 'orthogram' to
any orthonormal basis modelling phylogenetic topology.
Another example of such bases is offered by Moran's eigenvectors,
which can be used to model different observable phylogenetic
structures (see references in \code{me.phylo}).

Moran's phylogenetic eigenvectors are implemented by the function
\code{me.phylo} (also nicknamed \code{orthobasis.phylo}).
The returned object is a data.frame with the class \code{orthobasis}
defined in \code{ade4}; columns of this object are Moran's eigenvectors.
An \code{orthobasis} be coerced to a regular data.frame or to a matrix
using \code{as.data.frame} and \code{as.matrix}.
<<>>=
me.phylo(myTree.withBrLe)
@

\noindent Moran's eigenvectors are constructed from a matrix of
phylogenetic proximities between tips.
While any proximity can be used (argument \code{prox}), 5 proximities
implemented by the \code{proxTips} function can be used, giving rise
to different orthobases:
<<fig=TRUE>>=
ung.listBas <- list()
ung.listBas[[1]] <- phylo4d(myTree, as.data.frame(me.phylo(myTree.withBrLe, method="patristic")))
ung.listBas[[2]] <- phylo4d(myTree, as.data.frame(me.phylo(myTree, method="nNodes")))
ung.listBas[[3]]<- phylo4d(myTree, as.data.frame(me.phylo(myTree, method="Abouheif")))
ung.listBas[[4]] <- phylo4d(myTree, as.data.frame(me.phylo(myTree, method="sumDD")))
par(mar=rep(.1,4), mfrow=c(2,2))
lapply(ung.listBas, table.phylo4d, repVar=1:5, cex.sym=.7,
show.tip.label=FALSE, show.node=FALSE)
@

\noindent In this case, the first Moran's eigenvectors are all very
similar.
In other cases, the orthobases built from different proximities can be
quite different.



%%%%%%%%%%%%%%%%%%%%%
\subsection{Using multivariate analyses}
%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%
\subsection{Performing a phylogenetic Principal Component Analysis}
%%%%%%%%%%%%%%%%%%%%%




\end{document}
